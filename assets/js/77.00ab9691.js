(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{423:function(t,s,a){"use strict";a.r(s);var n=a(18),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"保持mysql和redis中数据的一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保持mysql和redis中数据的一致性"}},[t._v("#")]),t._v(" 保持mysql和redis中数据的一致性?")]),t._v(" "),a("h2",{attrs:{id:"_1、流程图说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、流程图说明"}},[t._v("#")]),t._v(" 1、流程图说明")]),t._v(" "),a("blockquote",[a("p",[t._v("缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。")])]),t._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"流程图说明",href:"https://img-blog.csdnimg.cn/20200729155714541.png"}},[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200729155714541.png",alt:"流程图说明"}})])]),t._v(" "),a("h2",{attrs:{id:"_2、疑问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、疑问"}},[t._v("#")]),t._v(" 2、疑问")]),t._v(" "),a("p",[t._v("在缓存和数据库同时存在时，如果有写操作的时候，先操作数据库还是先操作缓存呢？先思考一下，可能会存在哪些问题，再往下看。")]),t._v(" "),a("h2",{attrs:{id:"_3、更新策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、更新策略"}},[t._v("#")]),t._v(" 3、更新策略")]),t._v(" "),a("h3",{attrs:{id:"_3-1-先更新数据库，再更新缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-先更新数据库，再更新缓存"}},[t._v("#")]),t._v(" 3.1 先更新数据库，再更新缓存")]),t._v(" "),a("p",[a("strong",[t._v("这套方案，大家是普遍反对的。为什么呢？有如下两点原因。")])]),t._v(" "),a("h4",{attrs:{id:"_3-1-1-原因一（线程安全角度）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-原因一（线程安全角度）"}},[t._v("#")]),t._v(" 3.1.1 原因一（线程安全角度）")]),t._v(" "),a("p",[t._v("同时有请求A和请求B进行更新操作，那么会出现")]),t._v(" "),a("ul",[a("li",[t._v("1）线程A更新了数据库")]),t._v(" "),a("li",[t._v("2）线程B更新了数据库")]),t._v(" "),a("li",[t._v("3）线程B更新了缓存")]),t._v(" "),a("li",[t._v("4）线程A更新了缓存")])]),t._v(" "),a("p",[t._v("这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。")]),t._v(" "),a("h4",{attrs:{id:"_3-1-2-原因二（业务场景角度）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-原因二（业务场景角度）"}},[t._v("#")]),t._v(" 3.1.2 原因二（业务场景角度）")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。")])]),t._v(" "),a("li",[a("p",[t._v("（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。")])])]),t._v(" "),a("p",[a("strong",[a("code",[t._v("接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。")])])]),t._v(" "),a("h3",{attrs:{id:"_3-2-先删缓存，再更新数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-先删缓存，再更新数据库"}},[t._v("#")]),t._v(" 3.2 先删缓存，再更新数据库")]),t._v(" "),a("p",[t._v("该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:")]),t._v(" "),a("ul",[a("li",[t._v("1）请求A进行写操作，删除缓存")]),t._v(" "),a("li",[t._v("2）请求B查询发现缓存不存在")]),t._v(" "),a("li",[t._v("3）请求B去数据库查询得到旧值")]),t._v(" "),a("li",[t._v("4）请求B将旧值写入缓存")]),t._v(" "),a("li",[t._v("5）请求A将新值写入数据库")])]),t._v(" "),a("p",[t._v("上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。")]),t._v(" "),a("p",[t._v("那么，如何解决呢？采用延时双删策略")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n*解决方法的伪代码\n*/")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1、先删除缓存")]),t._v("\n\tredis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("delKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2、更新数据库，写入数据")]),t._v("\n\tdb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//3、休眠1秒")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//4、再次删除缓存")]),t._v("\n\tredis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("delKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("h4",{attrs:{id:"_3-2-1-休眠时间如何确定？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-1-休眠时间如何确定？"}},[t._v("#")]),t._v(" 3.2.1 休眠时间如何确定？")]),t._v(" "),a("p",[t._v("那么，这个1秒怎么确定的，具体该休眠多久呢？")]),t._v(" "),a("p",[t._v("需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。")]),t._v(" "),a("p",[t._v("当然，这种策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。")]),t._v(" "),a("h3",{attrs:{id:"_3-3-先更新数据库，再删缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-先更新数据库，再删缓存"}},[t._v("#")]),t._v(" 3.3 先更新数据库，再删缓存")]),t._v(" "),a("blockquote",[a("p",[t._v("首先，先说一下。老外提出了一个缓存更新套路，名为"),a("a",{attrs:{href:"https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside",target:"_blank",rel:"noopener noreferrer"}},[t._v("《Cache-Aside pattern》"),a("OutboundLink")],1),t._v("。其中就指出")]),t._v(" "),a("ul",[a("li",[t._v("失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。")]),t._v(" "),a("li",[t._v("命中：应用程序从cache中取数据，取到后返回。")]),t._v(" "),a("li",[t._v("更新：先把数据存到数据库中，成功后，再让缓存失效。")])])]),t._v(" "),a("p",[t._v("另外，知名社交网站facebook也在论文"),a("a",{attrs:{href:"https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("《Scaling Memcache at Facebook》"),a("OutboundLink")],1),t._v("中提出，他们用的也是先更新数据库，再删缓存的策略。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n*解决方法的伪代码\n*/")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("write")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1、更新数据库，写入数据")]),t._v("\n\tdb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("updateData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2、删除缓存")]),t._v("\n\tredis"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("delKey")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])]),a("h4",{attrs:{id:"_3-3-1-这种情况不存在并发问题么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-1-这种情况不存在并发问题么？"}},[t._v("#")]),t._v(" 3.3.1 这种情况不存在并发问题么？")]),t._v(" "),a("p",[t._v("不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生")]),t._v(" "),a("ul",[a("li",[t._v("1）缓存刚好失效")]),t._v(" "),a("li",[t._v("2）请求A查询数据库，得一个旧值")]),t._v(" "),a("li",[t._v("3）请求B将新值写入数据库")]),t._v(" "),a("li",[t._v("4）请求B删除缓存")]),t._v(" "),a("li",[t._v("5）请求A将查到的旧值写入缓存")])]),t._v(" "),a("p",[t._v("ok，如果发生上述情况，确实是会发生脏数据。")]),t._v(" "),a("h4",{attrs:{id:"_3-3-2-发生并发问题的概率是多少"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-2-发生并发问题的概率是多少"}},[t._v("#")]),t._v(" 3.3.2 发生并发问题的概率是多少?")]),t._v(" "),a("p",[t._v("发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。")]),t._v(" "),a("h4",{attrs:{id:"_3-3-3-如何解决上述并发问题？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-3-如何解决上述并发问题？"}},[t._v("#")]),t._v(" 3.3.3 如何解决上述并发问题？")]),t._v(" "),a("p",[t._v("首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作")]),t._v(" "),a("h2",{attrs:{id:"_4、最佳解决方案讨论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、最佳解决方案讨论"}},[t._v("#")]),t._v(" 4、最佳解决方案讨论")]),t._v(" "),a("h3",{attrs:{id:"_4-1-方案一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-方案一"}},[t._v("#")]),t._v(" 4.1 方案一")]),t._v(" "),a("p",[t._v("先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。")]),t._v(" "),a("h3",{attrs:{id:"_4-2-方案二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-方案二"}},[t._v("#")]),t._v(" 4.2 方案二")]),t._v(" "),a("p",[t._v("Redis里的数据总是不过期，但是有个背景更新任务（“定时执行的代码” 或者 “被队列驱动的代码）读取db，把最新的数据塞给Redis。这种做法将Redis看作是“存储”。访问者不知道背后的实际数据源，只知道Redis是唯一可以取的数据的地方。当实际数据源更新时，背景更新任务来将数据更新到Redis。这时还是会存在Redis和实际数据源不一致的问题。如果是定时任务，最长的不一致时长就是更新任务的执行间隔；如果是用类似于队列的方式来更新，那么不一致时间取决于队列产生和消费的延迟。常用的队列（或等价物）有Redis（怎么还是Redis），Kafka，AMQ，RMQ，binglog，log文件，阿里的canal等。")]),t._v(" "),a("h2",{attrs:{id:"_5、参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、参考资料"}},[t._v("#")]),t._v(" 5、参考资料")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.zhihu.com/question/319817091",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.zhihu.com/question/319817091"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/98909029",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://zhuanlan.zhihu.com/p/98909029"),a("OutboundLink")],1)]),t._v(" "),a("src-comment")],1)}),[],!1,null,null,null);s.default=e.exports}}]);